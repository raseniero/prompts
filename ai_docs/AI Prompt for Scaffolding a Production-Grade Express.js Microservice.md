### **AI Prompt for Scaffolding a Production-Grade Express.js Microservice**

**To the AI:** Please act as an expert software engineer. Your task is to generate a complete, production-grade Express.js microservice project based on the following detailed specifications. The project must use TypeScript, a layered architecture, and include configurations for PostgreSQL, MongoDB, Redis, and a comprehensive testing suite with Jest, Supertest, and Playwright.

Create each file exactly as specified with the given path and content.

### **Step 1: Create the Project Directory Structure**

First, create the following directory and file structure. Do not generate file content yet; just create the empty files and folders.

/express-microservice  
├── .dockerignore  
├── .env  
├── .env.example  
├── .eslintrc.js  
├── .gitignore  
├── .prettierrc  
├── docker-compose.yml  
├── Dockerfile  
├── Dockerfile.e2e  
├── jest.config.ts  
├── package.json  
├── playwright.config.ts  
├── README.md  
├── tsconfig.json  
├── e2e/  
│   ├── pages/  
│   │   └── register.page.ts  
│   └── register.spec.ts  
└── src/  
    ├── api/  
    │   └── users/  
    │       ├── user.controller.ts  
    │       ├── user.routes.ts  
    │       ├── user.service.ts  
    │       ├── user.service.spec.ts  
    │       ├── user.types.ts  
    │       └── user.validation.ts  
    ├── config/  
    │   └── index.ts  
    ├── database/  
    │   ├── models/  
    │   │   └── user.model.ts  
    │   ├── mongo.ts  
    │   ├── postgres.ts  
    │   └── redis.ts  
    ├── middleware/  
    │   ├── auth.middleware.ts  
    │   ├── error.middleware.ts  
    │   └── validation.middleware.ts  
    ├── server.ts  
    ├── types/  
    │   └── express/  
    │       └── index.d.ts  
    └── utils/  
        ├── ApiError.ts  
        └── logger.ts

### **Step 2: Install Dependencies**

Generate a package.json file. Then, provide the shell commands to install all necessary production and development dependencies.

**File: /express-microservice/package.json**

{  
  "name": "express-microservice-template",  
  "version": "1.0.0",  
  "description": "A production-grade template for Express.js microservices generated by AI.",  
  "main": "dist/server.js",  
  "scripts": {  
    "dev": "nodemon src/server.ts",  
    "build": "tsc",  
    "start": "node dist/server.js",  
    "test": "jest \--verbose \--runInBand",  
    "test:watch": "jest \--watch",  
    "test:e2e": "npx playwright test",  
    "test:e2e:report": "npx playwright show-report",  
    "lint": "eslint . \--ext .ts",  
    "lint:fix": "eslint . \--ext .ts \--fix"  
  },  
  "keywords": \["express", "typescript", "microservice", "nodejs", "template"\],  
  "author": "Your Name",  
  "license": "ISC"  
}

**Installation Commands:**

**Production Dependencies:**

npm install express@5.0.0-beta.3 helmet cors express-rate-limit dotenv zod winston bcryptjs jsonwebtoken pg mongoose redis

**Development Dependencies:**

npm install \-D typescript @types/node @types/express @types/helmet @types/cors @types/bcryptjs @types/jsonwebtoken @types/pg ts-node nodemon eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier eslint-config-prettier eslint-plugin-prettier jest @types/jest ts-jest supertest @types/supertest @playwright/test

### **Step 3: Generate All Project Files with Content**

Now, populate every file with the following content.

#### **Root Configuration Files**

**File: /express-microservice/tsconfig.json**

{  
  "compilerOptions": {  
    "target": "ES2022",  
    "module": "NodeNext",  
    "moduleResolution": "NodeNext",  
    "lib": \["ES2022"\],  
    "strict": true,  
    "esModuleInterop": true,  
    "skipLibCheck": true,  
    "forceConsistentCasingInFileNames": true,  
    "outDir": "./dist",  
    "rootDir": "./src",  
    "sourceMap": true,  
    "noUnusedLocals": true,  
    "noUnusedParameters": true,  
    "noImplicitReturns": true  
  },  
  "include": \["src/\*\*/\*", "e2e/\*\*/\*"\],  
  "exclude": \["node\_modules", "\*\*/\*.spec.ts"\]  
}

**File: /express-microservice/jest.config.ts**

import type { Config } from 'jest';

const config: Config \= {  
  preset: 'ts-jest',  
  testEnvironment: 'node',  
  verbose: true,  
  testMatch: \['\*\*/?(\*.)+(spec|test).\[jt\]s?(x)'\],  
  moduleNameMapper: {  
    '^@/(.\*)$': '\<rootDir\>/src/$1',  
  },  
};

export default config;

**File: /express-microservice/playwright.config.ts**

import { defineConfig, devices } from '@playwright/test';

export default defineConfig({  
  testDir: './e2e',  
  fullyParallel: true,  
  forbidOnly: \!\!process.env.CI,  
  retries: process.env.CI ? 2 : 0,  
  workers: process.env.CI ? 1 : undefined,  
  reporter: 'html',  
  use: {  
    baseURL: 'http://localhost:3001',  
    trace: 'on-first-retry',  
  },  
  projects: \[  
    { name: 'chromium', use: { ...devices\['Desktop Chrome'\] } },  
    { name: 'firefox', use: { ...devices\['Desktop Firefox'\] } },  
    { name: 'webkit', use: { ...devices\['Desktop Safari'\] } },  
  \],  
  webServer: {  
    command: 'npm run start',  
    url: 'http://localhost:3001',  
    reuseExistingServer: \!process.env.CI,  
  },  
});

**File: /express-microservice/.env.example**

\# Application Configuration  
NODE\_ENV=development  
PORT=3001  
LOG\_LEVEL=debug

\# Security  
CORS\_ORIGIN=http://localhost:3000  
JWT\_SECRET=a-very-strong-and-secret-key  
JWT\_EXPIRES\_IN=1d

\# Databases  
POSTGRES\_URL=postgresql://postgres:password@localhost:5432/mydatabase  
MONGO\_URL=mongodb://localhost:27017/mydatabase  
REDIS\_URL=redis://localhost:6379

**File: /express-microservice/.gitignore**

\# Dependencies  
/node\_modules

\# Build output  
/dist

\# Logs  
\*.log  
npm-debug.log\*  
yarn-debug.log\*  
yarn-error.log\*

\# Environment variables  
.env  
.env.local  
.env.development.local  
.env.test.local  
.env.production.local

\# Test reports  
/coverage  
/playwright-report/  
/test-results/

**File: /express-microservice/Dockerfile**

\# Stage 1: Builder  
FROM node:22-alpine AS builder  
WORKDIR /app  
COPY package\*.json ./  
RUN npm ci  
COPY . .  
RUN npm run build

\# Stage 2: Production  
FROM node:22-alpine  
WORKDIR /app  
COPY package\*.json ./  
RUN npm ci \--omit=dev  
COPY \--from=builder /app/dist ./dist  
EXPOSE 3001  
CMD \["node", "dist/server.js"\]

**File: /express-microservice/Dockerfile.e2e**

FROM mcr.microsoft.com/playwright:v1.44.0-jammy  
WORKDIR /app  
COPY package\*.json ./  
RUN npm ci  
COPY . .

**File: /express-microservice/docker-compose.yml**

version: '3.8'  
services:  
  app:  
    build:  
      context: .  
      dockerfile: Dockerfile  
    ports:  
      \- "3001:3001"  
    volumes:  
      \- ./src:/app/src  
    env\_file: .env  
    depends\_on:  
      \- postgres  
      \- mongo  
      \- redis  
    command: npm run dev

  postgres:  
    image: postgres:16-alpine  
    environment:  
      POSTGRES\_USER: postgres  
      POSTGRES\_PASSWORD: password  
      POSTGRES\_DB: mydatabase  
    ports:  
      \- "5432:5432"  
    volumes:  
      \- postgres\_data:/var/lib/postgresql/data

  mongo:  
    image: mongo:7.0  
    ports:  
      \- "27017:27017"  
    volumes:  
      \- mongo\_data:/data/db

  redis:  
    image: redis:7-alpine  
    ports:  
      \- "6379:6379"  
    volumes:  
      \- redis\_data:/data

  playwright-tests:  
    build:  
      context: .  
      dockerfile: Dockerfile.e2e  
    network\_mode: host  
    depends\_on:  
      \- app  
    volumes:  
      \- ./e2e:/app/e2e  
      \- ./playwright-report:/app/playwright-report

volumes:  
  postgres\_data:  
  mongo\_data:  
  redis\_data:

#### **Source (src) Directory Files**

**File: /express-microservice/src/server.ts**

import express, { Express, Request, Response } from 'express';  
import helmet from 'helmet';  
import cors from 'cors';  
import config from './config';  
import logger from './utils/logger';  
import { errorMiddleware } from './middleware/error.middleware';  
import { ApiError } from './utils/ApiError';  
import userRouter from './api/users/user.routes';

const app: Express \= express();

// Middleware  
app.use(helmet());  
app.use(cors({ origin: config.corsOrigin }));  
app.use(express.json());  
app.use(express.urlencoded({ extended: true }));

// Routes  
app.get('/', (req: Request, res: Response) \=\> {  
  res.status(200).json({ message: 'API is healthy' });  
});  
app.use('/api/v1/users', userRouter);

// Error Handling  
app.use((req, res, next) \=\> next(new ApiError(404, 'Not Found')));  
app.use(errorMiddleware);

// Start Server  
app.listen(config.port, () \=\> {  
  logger.info(\`Server running on port ${config.port} in ${config.nodeEnv} mode.\`);  
});

export default app; // Export for testing

**File: /express-microservice/src/config/index.ts**

import dotenv from 'dotenv';  
import path from 'path';  
import { z } from 'zod';

dotenv.config({ path: path.resolve(\_\_dirname, \`../../.env\`) });

const envSchema \= z.object({  
  NODE\_ENV: z.enum(\['development', 'production', 'test'\]).default('development'),  
  PORT: z.coerce.number().default(3001),  
  LOG\_LEVEL: z.string().default('info'),  
  CORS\_ORIGIN: z.string().default('\*'),  
  JWT\_SECRET: z.string().min(1, 'JWT\_SECRET is required'),  
  JWT\_EXPIRES\_IN: z.string().default('1d'),  
  POSTGRES\_URL: z.string().url(),  
  MONGO\_URL: z.string().url(),  
  REDIS\_URL: z.string().url(),  
});

const parsedEnv \= envSchema.safeParse(process.env);

if (\!parsedEnv.success) {  
  console.error('Invalid environment variables:', parsedEnv.error.flatten().fieldErrors);  
  throw new Error('Invalid environment variables.');  
}

const config \= {  
  nodeEnv: parsedEnv.data.NODE\_ENV,  
  port: parsedEnv.data.PORT,  
  logLevel: parsedEnv.data.LOG\_LEVEL,  
  corsOrigin: parsedEnv.data.CORS\_ORIGIN,  
  jwt: {  
    secret: parsedEnv.data.JWT\_SECRET,  
    expiresIn: parsedEnv.data.JWT\_EXPIRES\_IN,  
  },  
  db: {  
    postgresUrl: parsedEnv.data.POSTGRES\_URL,  
    mongoUrl: parsedEnv.data.MONGO\_URL,  
    redisUrl: parsedEnv.data.REDIS\_URL,  
  },  
};

export default config;

**File: /express-microservice/src/api/users/user.routes.ts**

import { Router } from 'express';  
import \* as controller from './user.controller';  
import { validate } from '../../middleware/validation.middleware';  
import { UserRegistrationSchema, UserLoginSchema } from './user.validation';

const router \= Router();

router.post('/register', validate(UserRegistrationSchema), controller.registerUser);  
router.post('/login', validate(UserLoginSchema), controller.loginUser);

export default router;

**File: /express-microservice/src/api/users/user.controller.ts**

import { Request, Response, NextFunction } from 'express';  
import \* as service from './user.service';  
import { UserRegistrationInput } from './user.types';

export const registerUser \= async (req: Request, res: Response, next: NextFunction) \=\> {  
  try {  
    const userInput: UserRegistrationInput \= req.body;  
    const { user, token } \= await service.registerNewUser(userInput);  
    res.status(201).json({  
      message: 'User registered successfully',  
      data: { user, token },  
    });  
  } catch (error) {  
    next(error);  
  }  
};

export const loginUser \= async (req: Request, res: Response, next: NextFunction) \=\> {  
  try {  
    const { email, password } \= req.body;  
    const { user, token } \= await service.loginUser(email, password);  
    res.status(200).json({  
      message: 'Login successful',  
      data: { user, token },  
    });  
  } catch (error) {  
    next(error);  
  }  
};

**File: /express-microservice/src/api/users/user.service.ts**

import bcrypt from 'bcryptjs';  
import jwt from 'jsonwebtoken';  
import { UserRegistrationInput, UserPublicData } from './user.types';  
import { ApiError } from '../../utils/ApiError';  
import UserModel from '../../database/models/user.model';  
import config from '../../config';

export const registerNewUser \= async (  
  userData: UserRegistrationInput  
): Promise\<{ user: UserPublicData; token: string }\> \=\> {  
  const existingUser \= await UserModel.findOne({ email: userData.email });  
  if (existingUser) {  
    throw new ApiError(409, 'Email already in use');  
  }

  const hashedPassword \= await bcrypt.hash(userData.password, 10);  
  const newUser \= await UserModel.create({ ...userData, password: hashedPassword });

  const userPublicData \= {  
    id: newUser.id,  
    name: newUser.name,  
    email: newUser.email,  
  };

  const token \= jwt.sign({ id: newUser.id }, config.jwt.secret, {  
    expiresIn: config.jwt.expiresIn,  
  });

  return { user: userPublicData, token };  
};

export const loginUser \= async (  
  email: string,  
  password: string  
): Promise\<{ user: UserPublicData; token: string }\> \=\> {  
  const user \= await UserModel.findOne({ email }).select('+password');  
  if (\!user || \!(await bcrypt.compare(password, user.password))) {  
    throw new ApiError(401, 'Invalid credentials');  
  }

  const userPublicData \= { id: user.id, name: user.name, email: user.email };  
  const token \= jwt.sign({ id: user.id }, config.jwt.secret, {  
    expiresIn: config.jwt.expiresIn,  
  });

  return { user: userPublicData, token };  
};

**File: /express-microservice/src/database/models/user.model.ts**

import { Schema, model } from 'mongoose';

const userSchema \= new Schema(  
  {  
    name: { type: String, required: true },  
    email: { type: String, required: true, unique: true, lowercase: true },  
    password: { type: String, required: true, select: false },  
  },  
  { timestamps: true }  
);

const UserModel \= model('User', userSchema);  
export default UserModel;

**File: /express-microservice/src/api/users/user.validation.ts**

import { z } from 'zod';

export const UserRegistrationSchema \= z.object({  
  body: z.object({  
    name: z.string().min(2),  
    email: z.string().email(),  
    password: z.string().min(8),  
  }),  
});

export const UserLoginSchema \= z.object({  
  body: z.object({  
    email: z.string().email(),  
    password: z.string(),  
  }),  
});

**File: /express-microservice/src/api/users/user.types.ts**

import { z } from 'zod';  
import { UserRegistrationSchema } from './user.validation';

export type UserRegistrationInput \= z.infer\<typeof UserRegistrationSchema\>\['body'\];

export interface UserPublicData {  
  id: string;  
  name: string;  
  email: string;  
}

**File: /express-microservice/src/middleware/validation.middleware.ts**

import { Request, Response, NextFunction } from 'express';  
import { AnyZodObject } from 'zod';

export const validate \=  
  (schema: AnyZodObject) \=\>  
  async (req: Request, res: Response, next: NextFunction) \=\> {  
    try {  
      await schema.parseAsync({  
        body: req.body,  
        query: req.query,  
        params: req.params,  
      });  
      return next();  
    } catch (error) {  
      next(error);  
    }  
  };

**File: /express-microservice/src/middleware/error.middleware.ts**

import { Request, Response, NextFunction } from 'express';  
import { ZodError } from 'zod';  
import { ApiError } from '../utils/ApiError';  
import logger from '../utils/logger';

export const errorMiddleware \= (  
  error: Error,  
  req: Request,  
  res: Response,  
  next: NextFunction  
) \=\> {  
  if (error instanceof ApiError) {  
    return res.status(error.statusCode).json({ message: error.message });  
  }  
  if (error instanceof ZodError) {  
    return res.status(400).json({ errors: error.errors });  
  }  
  logger.error(error.message, { stack: error.stack });  
  return res.status(500).json({ message: 'Internal Server Error' });  
};

**File: /express-microservice/src/utils/ApiError.ts**

export class ApiError extends Error {  
  constructor(public statusCode: number, message: string) {  
    super(message);  
  }  
}

**File: /express-microservice/src/utils/logger.ts**

import winston from 'winston';  
import config from '../config';

const logger \= winston.createLogger({  
  level: config.logLevel,  
  format: winston.format.combine(  
    winston.format.timestamp(),  
    winston.format.json()  
  ),  
  transports: \[new winston.transports.Console()\],  
});

export default logger;

#### **Testing Files**

**Sample Unit Test (Component Test)**

This test focuses on a single "component" or unit—the user.service. It mocks dependencies like the database model to test the business logic in isolation.

**File: /express-microservice/src/api/users/user.service.spec.ts**

import \* as userService from './user.service';  
import UserModel from '../../database/models/user.model';  
import { ApiError } from '../../utils/ApiError';  
import bcrypt from 'bcryptjs';  
import jwt from 'jsonwebtoken';

// Mock dependencies  
jest.mock('../../database/models/user.model');  
jest.mock('bcryptjs');  
jest.mock('jsonwebtoken');

const mockUserModel \= UserModel as jest.Mocked\<typeof UserModel\>;  
const mockBcrypt \= bcrypt as jest.Mocked\<typeof bcrypt\>;  
const mockJwt \= jwt as jest.Mocked\<typeof jwt\>;

describe('User Service', () \=\> {  
  afterEach(() \=\> {  
    jest.clearAllMocks();  
  });

  describe('registerNewUser', () \=\> {  
    it('should register a new user successfully', async () \=\> {  
      const userInput \= { name: 'Test', email: 'test@test.com', password: 'password123' };  
      mockUserModel.findOne.mockResolvedValue(null);  
      mockBcrypt.hash.mockResolvedValue('hashedPassword');  
      const mockUser \= { id: '1', ...userInput, password: 'hashedPassword' };  
      (UserModel.create as jest.Mock).mockResolvedValue(mockUser);  
      mockJwt.sign.mockReturnValue('token');

      const result \= await userService.registerNewUser(userInput);

      expect(result.user).toEqual({ id: '1', name: 'Test', email: 'test@test.com' });  
      expect(result.token).toBe('token');  
      expect(UserModel.create).toHaveBeenCalledWith({  
        ...userInput,  
        password: 'hashedPassword',  
      });  
    });

    it('should throw a 409 error if email is already in use', async () \=\> {  
      const userInput \= { name: 'Test', email: 'test@test.com', password: 'password123' };  
      mockUserModel.findOne.mockResolvedValue({ id: '1' });

      await expect(userService.registerNewUser(userInput)).rejects.toThrow(  
        new ApiError(409, 'Email already in use')  
      );  
    });  
  });  
});

**Sample End-to-End (E2E) API Test**

This test uses Supertest to make a real HTTP request to the /register endpoint and verify the response, testing the full request-response cycle.

**File: /express-microservice/e2e/api.e2e.spec.ts** (Create this new file)

import request from 'supertest';  
import app from '../../src/server'; // Import your express app  
import UserModel from '../../src/database/models/user.model';

jest.mock('../../src/database/models/user.model');  
const mockUserModel \= UserModel as jest.Mocked\<typeof UserModel\>;

describe('POST /api/v1/users/register', () \=\> {  
  it('should register a user and return 201', async () \=\> {  
    const userData \= {  
      name: 'E2E Test User',  
      email: 'e2e@test.com',  
      password: 'password123',  
    };

    // Mock the database interaction  
    mockUserModel.findOne.mockResolvedValue(null);  
    (UserModel.create as jest.Mock).mockResolvedValue({  
      id: 'mock-id',  
      ...userData,  
    });  
      
    const response \= await request(app)  
      .post('/api/v1/users/register')  
      .send(userData);

    expect(response.status).toBe(201);  
    expect(response.body.message).toBe('User registered successfully');  
    expect(response.body.data.user.email).toBe(userData.email);  
    expect(response.body.data.token).toBeDefined();  
  });  
});

**Sample End-to-End (E2E) Browser Test with Playwright**

This test uses Playwright to launch a browser, navigate to a hypothetical front-end page, and test the registration flow from a user's perspective.

**File: /express-microservice/e2e/register.spec.ts**

import { test, expect, Page } from '@playwright/test';

// This is a placeholder test. It assumes a front-end application exists  
// and has input fields for name, email, and password, and a register button.  
// For this to run, you would need a simple HTML file or a front-end framework.

const createDummyRegisterPage \= async (page: Page) \=\> {  
  await page.setContent(\`  
    \<html\>  
      \<body\>  
        \<input name="name" placeholder="Name" /\>  
        \<input name="email" placeholder="Email" /\>  
        \<input type="password" name="password" placeholder="Password" /\>  
        \<button\>Register\</button\>  
        \<div id="message"\>\</div\>  
      \</body\>  
    \</html\>  
  \`);  
};

test.describe('User Registration E2E', () \=\> {  
  test('should display success message after registration', async ({ page }) \=\> {  
    // Mock the API endpoint  
    await page.route('\*\*/api/v1/users/register', async (route) \=\> {  
      await route.fulfill({  
        status: 201,  
        contentType: 'application/json',  
        body: JSON.stringify({ message: 'User registered successfully' }),  
      });  
    });  
      
    await createDummyRegisterPage(page);

    await page.getByPlaceholder('Name').fill('Browser Test');  
    await page.getByPlaceholder('Email').fill('browser@test.com');  
    await page.getByPlaceholder('Password').fill('password123');  
    await page.getByRole('button', { name: 'Register' }).click();

    // This part would need to be adapted to how your front-end displays messages  
    // For this dummy page, we can't easily test the success message.  
    // In a real app, you would assert:  
    // await expect(page.locator('\#success-message')).toBeVisible();  
      
    // For now, we just confirm the test runs.  
    expect(true).toBe(true);  
  });  
});

### **Final Instructions**

After generating all files, the project is complete. The developer can then run npm install to get all dependencies, copy .env.example to .env and fill in the values, and then use npm run dev to start the development server. Tests can be run with npm test (for unit/API tests) and npm run test:e2e (for browser tests).